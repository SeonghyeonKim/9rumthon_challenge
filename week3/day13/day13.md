# 문제 13. 발전기 (2)

예상 티어: 실버 4
예상 태그: 깊이 우선 탐색, 너비 우선 탐색

<br>

## 문제 설명

N x N의 타일에 1에서 30까지의 숫자가 적혀있다.
상하좌우로 인접하고 동일한 숫자라면 연결되어있다고 했을때, 
K개 이상 연결된 컴포넌트의 수가 많은 숫자를 출력해라.

1 <= N <= 1000
1 <= K <= 50
1 <= Mr,c <= 30


<br>

## 문제 해결

이전 BFS 코드를 바탕으로 작성했다.
BFS를 통해 같은 숫자를 하나의 컴포넌트로 여기고 탐색했다.
탐색이 종료된 후, 컴포넌트에 속한 요소가 K개 이상인 경우,
해당 숫자의 컴포넌트 수를 증가시켰다.
```
while(!q.empty()) {
	pii c = q.front();
	q.pop();
	tmp++;

	for(int i=0; i<4; i++) {
		int nx = c.first + dx[i];
		int ny = c.second + dy[i];

		if(nx>=0 && nx<N && ny>=0 && ny<N && visited[nx][ny]==0 && M[nx][ny]==num) {
			visited[nx][ny] = 1;
			q.push({nx, ny});
		}
	}
}

// 건물이 K개 이상인 경우, 개수 증가
if(tmp >= K) cnt[num]++;
```

전체 탐색이 끝난 경우, 최대값을 가지는 숫자 유형을 출력한다.
```
// ans: 최대값을 가지는 건물의 유형, tmp: 최대값
int ans = 30, tmp = 0;
for(int i=0; i<=30; i++) {
	if(tmp <= cnt[i]) {
		tmp = cnt[i];
		ans = i;
	}
}
cout << ans;
```


<br>

## 문제 후기

이전에 풀었던 발전기 문제에서 조건이 추가된 문제였다.
이 문제 또한 스택을 사용한 DFS를 통해 해결할 수 있다.


<br>