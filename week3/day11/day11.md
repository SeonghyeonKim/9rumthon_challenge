# 문제 11. 통증 (2)

예상 티어: 브론즈 1
예상 태그: DP, 구현

<br>

## 문제 설명

통증 수치를 낮춰주는 2가지 아이템 A, B가 있다.
각각 Ap, Bp 만큼 통증 수치를 낮춰준다.
N의 통증 수치를 가지고 있을 때, 통증 수치를 0으로 줄이기 위한 아이템의 최소 개수를 출력해라.
단 0이 되지 않을 경우 -1을 출력해라.

2 <= N <= 10^6
2 <= Ap < Bp <= 13
Ap와 Bp는 배수 관계가 아니다.

<br>

## 문제 해결

결국 Ap * cntA + Bp * cntB 가 N이 될 때 cntA + cntB의 합을 최소로 만드는 값을 구해야 한다.
Bp는 항상 Ap보다 크기 때문에 cntB가 최대이면서, Ap * cntA + Bp * cntB == N인 경우가 아이템의 수가 최소가 된다.
따라서 cntB가 최대일 경우부터 시작하여 0이 될 때까지 경우의 수를 고려한다.

```cpp
// cnta: A 아이템의 수, cntb: B 아이템의 수
int cnta = 0, cntb = N / Bp;
while(cntb >= 0) {
	cnta = (N - cntb*Bp) / Ap;

	// 정확하게 통증 수치가 0인 경우
	if(cnta*Ap + cntb*Bp == N) {
		cout << cnta + cntb;
		return 0;
	}
	cntb--;
}
```

<br>

## 문제 후기

지난번에 풀었던 통증에서 조건이 추가된 문제다.
문제를 보자마자 생각하낸 풀이를 작성했더니 정답을 받았다.

결국 최대 N/Bp 만큼의 반복문이 실행되고, 
조건에 따라 최대 333334번이 실행된다.

숫자가 크지않아 그냥 제출했다.


<br>