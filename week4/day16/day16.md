# 문제 16. 연합

예상 티어: 실버 4
예상 태그: 그래프 탐색, BFS, DFS

<br>

## 문제 설명

1번 부터 N번 까지의 섬과 섬을 이어주는 M개의 단방향 다리가 있다.
a번 섬과 b번 섬을 서로 직접 이동할 수 있는 다리가 있는 경우, 연합을 결성한다.
a번 섬과 b번 섬이 연합이고, b번 섬과 c번 섬이 연합이면, a번 섬과 c번 섬도 연합이다.
N개의 섬 사이에 존재하는 연합의 수를 출력하라.

1 <= N <= 2000
1 <= M <= 2000000

<br>

## 문제 해결

인접 행렬을 통해 단방향 다리를 기록했다.
```cpp
int v[2001][2001];

// 인접 행렬을 통해 간선 생성
for(int i=0; i<M; i++) {
	int s, e;
	cin >> s >> e;

	v[s][e] = 1;
}
```

이 인접행렬을 통해 양방향 다리의 존재를 O(1)에 확인할 수 있다.
```cpp
for(int i=1; i<=N; i++) {
	// 방문한 적이 없고, 양방향 간선이 존재한다면,
	if(visited[i]==0 && v[c][i]==1 && v[i][c]==1) {
		visited[i] = 1;
		q.push(i);
	}
}
```

BFS를 통해 연합을 탐색하므로, BFS의 실행 횟수가 연합의 수가 된다.
```cpp
// cnt: 연합의 수
int cnt=0;
for(int i=1; i<=N; i++) {
	if(visited[i]==0) {
		cnt++;
		BFS(i);
	}
}
```


<br>

## 문제 후기

처음에는 사이클이 형성되면 하나의 연합이 되는 줄 알았다.
역시나 내가 문제를 잘못 이해한 것이었다.
'직접' 연결 되어있어야지만 연합이라고 강조했으나, 넘어갔던 것이었다...

이제 마지막 주차가 되었다.
아쉬운 느낌이 든다.


<br>